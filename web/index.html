<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>EOSBF 2025 | Escolha de Sessões</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

  <style>
    code {
      background-color: #ededed;
      border-radius: 6px;
      padding: 2px 6px;
    }
  </style>
</head>

<body class="bg-gray-50 p-6 font-sans pb-20">
  <!-- Fixed Top Buttons -->
  <div class="fixed top-0 left-0 right-0 bg-white shadow-md p-3 z-10">
    <!-- Desktop Header -->
    <div class="hidden md:flex justify-between items-center">
      <div>
        <h1 class="text-xl font-bold text-gray-800">EOSBF 2025</h1>
        <p class="text-sm text-gray-600">Escolha de Sessões</p>
      </div>
      <div class="flex space-x-3 items-center justify-center">
        <a href="https://www.eventweb.com.br/eosbf2025/home-event/schedule.php?q=&area=todas&sessao=todas&tipo=1#trabalhos"
          target="_blank" class="cursor-pointer">Lista
          oficial de trabalhos</a>
        <button id="shareUrlBtn"
          class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md font-medium transition-colors duration-200 flex items-center cursor-pointer"
          onclick="shareSelections()">
          🔗 Compartilhar
        </button>
        <button id="viewSummaryBtn"
          class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md font-medium transition-colors duration-200 flex items-center cursor-pointer opacity-50 pointer-events-none">
          📋 Ver Resumo
        </button>
        <button id="clearAllBtn"
          class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md font-medium transition-colors duration-200 flex items-center cursor-pointer opacity-50 pointer-events-none">
          &cross; Limpar escolhas
        </button>
      </div>
    </div>
    
    <!-- Mobile Header -->
    <div class="flex md:hidden justify-between items-center">
      <div>
        <h1 class="text-lg font-bold text-gray-800">EOSBF 2025</h1>
        <p class="text-xs text-gray-600">Escolha de Sessões</p>
      </div>
      <div class="flex space-x-2 items-center">
        <button id="shareUrlBtnMobile"
          class="bg-green-500 hover:bg-green-600 text-white px-3 py-1.5 rounded-md text-sm font-medium transition-colors duration-200 flex items-center cursor-pointer"
          onclick="shareSelections()">
          🔗
        </button>
        <button id="viewSummaryBtnMobile"
          class="bg-green-500 hover:bg-green-600 text-white px-3 py-1.5 rounded-md text-sm font-medium transition-colors duration-200 flex items-center cursor-pointer opacity-50 pointer-events-none">
          📋
        </button>
        <button id="mobileMenuBtn" class="text-gray-500 hover:text-gray-700 text-xl px-1 py-1">
          ☰
        </button>
      </div>
    </div>
    
    <!-- Mobile Menu (hidden by default) -->
    <div id="mobileMenu" class="hidden md:hidden mt-3 p-3 bg-gray-100 rounded-b-lg">
      <div class="flex flex-col space-y-3">
        <a href="https://www.eventweb.com.br/eosbf2025/home-event/schedule.php?q=&area=todas&sessao=todas&tipo=1#trabalhos"
          target="_blank" class="cursor-pointer text-blue-600">Lista oficial de trabalhos</a>
        <button id="clearAllBtnMobile"
          class="bg-red-500 hover:bg-red-600 text-white px-3 py-1.5 rounded-md text-sm font-medium transition-colors duration-200 flex items-center justify-center cursor-pointer opacity-50 pointer-events-none">
          &cross; Limpar escolhas
        </button>
      </div>
    </div>
  </div>

  <div class="max-w-[1800px] mx-auto bg-white rounded-lg shadow-sm p-6 mt-16 md:mt-20">
    <!-- Sessions Groups Container -->
    <div id="sessionsContainer"></div>
  </div>

  <script>
    let sessions = [];

    // Toggle mobile menu
    document.getElementById('mobileMenuBtn').addEventListener('click', function() {
      const mobileMenu = document.getElementById('mobileMenu');
      mobileMenu.classList.toggle('hidden');
    });

    // Close any open modal when pressing Escape
    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        document.getElementById('presentationsModal')?.remove();
        document.getElementById('summaryModal')?.remove();
      }
    }, false);

    // Update button states
    function updateButtons() {
      const clearButton = document.getElementById('clearAllBtn');
      const summaryButton = document.getElementById('viewSummaryBtn');
      const clearButtonMobile = document.getElementById('clearAllBtnMobile');
      const summaryButtonMobile = document.getElementById('viewSummaryBtnMobile');
      const selectedSessions = getSelectedSessions();
      const hasSelections = Object.keys(selectedSessions).length > 0;

      if (hasSelections) {
        clearButton.classList.remove('opacity-50', 'pointer-events-none');
        summaryButton.classList.remove('opacity-50', 'pointer-events-none');
        clearButtonMobile.classList.remove('opacity-50', 'pointer-events-none');
        summaryButtonMobile.classList.remove('opacity-50', 'pointer-events-none');
      } else {
        clearButton.classList.add('opacity-50', 'pointer-events-none');
        summaryButton.classList.add('opacity-50', 'pointer-events-none');
        clearButtonMobile.classList.add('opacity-50', 'pointer-events-none');
        summaryButtonMobile.classList.add('opacity-50', 'pointer-events-none');
      }
    }

    // Group sessions by date and time
    function groupSessionsByDateTime() {
      const groups = {};

      sessions.forEach(session => {
        // Extract just the start time without the end time
        const startTime = session.time.split('-')[0];
        const key = `${session.date}-${startTime}`;
        
        if (!groups[key]) {
          groups[key] = {
            date: session.date,
            time: startTime, // Only use start time for grouping
            fullTimeRange: session.time, // Keep the full time range for display
            sessions: []
          };
        }
        groups[key].sessions.push(session);
      });

      // Sort groups by date and time
      return Object.values(groups).sort((a, b) => {
        // First compare dates
        const dateComparison = a.date.localeCompare(b.date);
        if (dateComparison !== 0) return dateComparison;
        
        // If dates are equal, compare times
        // Convert times to minutes for numeric comparison
        const getMinutes = (timeStr) => {
          const parts = timeStr.replace(/[h:]/, '').split(/[h:]/);
          if (parts.length >= 2) {
            return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
          }
          return parseInt(parts[0]) * 60;
        };
        
        return getMinutes(a.time) - getMinutes(b.time);
      });
    }

    // Display sessions grouped by date and time
    function displaySessions() {
      const container = document.getElementById('sessionsContainer');
      container.innerHTML = '';

      const groups = groupSessionsByDateTime();
      const selectedSessions = getSelectedSessions();

      groups.forEach(group => {
        const dateFormatted = formatDate(group.date);
        const groupElement = document.createElement('div');
        groupElement.className = 'mb-8 pb-6 border-b border-gray-300';

        const groupHeader = document.createElement('h2');
        groupHeader.className = 'text-2xl font-semibold mb-3 text-gray-700';
        // Use fullTimeRange if available for display purposes
        const displayTime = group.fullTimeRange || group.time;
        groupHeader.innerHTML = `${dateFormatted} ${displayTime}`;
        groupElement.appendChild(groupHeader);

        // For selection purposes, use only the start time
        const alreadySelected = group.sessions.some(session => {
          const sessionStartTime = session.time.split('-')[0];
          const key = `${session.date}-${sessionStartTime}`;
          return selectedSessions[key];
        });

        if (alreadySelected) {
          // Get the selected session using only the start time
          const startTime = group.time; // This is already the start time from our updated grouping function
          const selectedSessionKey = `${group.date}-${startTime}`;
          const selectedSessionId = selectedSessions[selectedSessionKey];
          // Use case-insensitive comparison
          const selectedSession = group.sessions.find(s => 
            s.session.toLowerCase() === selectedSessionId.toLowerCase()
          );

          // Check if session was found (should not happen with our fixes, but good defensive coding)
          if (!selectedSession) {
            // Skip this group or show a default message
            const errorMsg = document.createElement('div');
            errorMsg.className = 'p-3 bg-red-50 text-red-700 rounded-md';
            errorMsg.innerText = `Não foi possível encontrar a sessão "${selectedSessionId}" neste horário.`;
            groupElement.appendChild(errorMsg);
            return;
          }

          // Normal case when selected session is found - we now handle case sensitivity 
          // and start time issues, so we should always find the session
          const selectionInfo = document.createElement('div');
          selectionInfo.className = 'p-4 bg-blue-50 border border-blue-200 rounded-lg mb-3 relative';
          selectionInfo.innerHTML = `
                      <div class="absolute top-2 right-2">
                          <button class="text-red-500 hover:text-red-700 cursor-pointer text-2xl" 
                                  data-key="${group.date}-${startTime}"
                                  onclick="removeSession('${group.date}-${startTime}')">
                              &cross;
                          </button>
                      </div>
                      <div class="flex items-center mb-2">
                          <span class="bg-green-200 text-green-800 text-xs font-medium px-2 py-1 rounded">&#9989; Selecionada</span>
                      </div>
                      <p class="font-medium text-lg">${selectedSession.session}</p>
                      <p class="text-sm text-gray-600">${selectedSession.location}</p>
                      <p class="text-sm text-gray-600">${selectedSession.presentations.length} ${selectedSession.presentations.length > 1 ? "apresentações" : "apresentação"}</p>
                      <div class="mt-3 flex space-x-3">
                          <button class="text-sm text-blue-600 hover:text-blue-800 flex items-center cursor-pointer"
                                  onclick="showPresentations('${selectedSession.session}')">
                              Ver Apresentações
                          </button>
                          <button class="text-sm text-blue-600 hover:text-blue-800 flex items-center cursor-pointer"
                                  onclick="toggleSessionOptions('${group.date}-${startTime}')">
                              Trocar Seleção
                          </button>
                          <a href="${createGoogleCalendarLink(group.date, displayTime, selectedSession.session, selectedSession.location)}" 
                             target="_blank"
                             class="text-sm text-green-600 hover:text-green-800 flex items-center cursor-pointer">
                             📅 Adicionar ao Calendário
                          </a>
                      </div>
                  `;
          groupElement.appendChild(selectionInfo);

          // Add hidden session options that will be shown when "Trocar Seleção" is clicked
          const sessionsContainer = document.createElement('div');
          sessionsContainer.className = 'hidden session-options grid grid-cols-1 md:grid-cols-3 gap-4';
          sessionsContainer.id = `session-options-${group.date}-${startTime}`;

          group.sessions.forEach(session => {
            const sessionCard = createSessionCard(session, group.date, group.time);
            sessionsContainer.appendChild(sessionCard);
          });

          groupElement.appendChild(sessionsContainer);
        } else {
          // Show all sessions in this group for selection
          const sessionsContainer = document.createElement('div');
          sessionsContainer.className = 'grid grid-cols-1 md:grid-cols-3 gap-4';

          group.sessions.forEach(session => {
            const sessionCard = createSessionCard(session, group.date, group.time);
            sessionsContainer.appendChild(sessionCard);
          });

          groupElement.appendChild(sessionsContainer);
        }

        container.appendChild(groupElement);
      });
    }

    // Toggle session options visibility
    function toggleSessionOptions(key) {
      // Ensure we're using the start time only for the key
      const [date, fullTime] = key.split('-');
      const startTime = fullTime.split('-')[0];
      const normalizedKey = `${date}-${startTime}`;
      
      const optionsContainer = document.getElementById(`session-options-${normalizedKey}`);
      if (optionsContainer) {
        optionsContainer.classList.toggle('hidden');
        // Also hide the selection info when showing options
        const selectionInfo = optionsContainer.previousElementSibling;
        if (!optionsContainer.classList.contains('hidden')) {
          selectionInfo.classList.add('hidden');
        } else {
          selectionInfo.classList.remove('hidden');
        }
      }
    }

    // Create a card for a session
    function createSessionCard(session, date, time) {
      const card = document.createElement('div');
      card.className = 'border border-gray-300 p-4 rounded-lg shadow-sm hover:shadow transition-shadow duration-200 bg-white';

      // Calculate total presentations
      const presentationsCount = session.presentations.length;

      // Get unique fields from presentations
      const fields = [...new Set(session.presentations.map(p => p.field))];

      // Limit fields to 3 for display
      const displayFields = fields.length > 3
        ? fields.slice(0, 3).join(', ') + ` +${fields.length - 3}`
        : fields.join(', ');

      card.innerHTML = `
                <h3 class="font-medium text-lg mb-2 text-gray-800">${session.session}</h3>
                <div class="space-y-1 mb-3">
                    <p class="text-sm text-gray-600">${session.location}</p>
                    <p class="text-sm text-gray-600">${presentationsCount} ${presentationsCount > 1 ? "apresentações" : "apresentação"}</p>
                    <p class="text-sm text-gray-600">${displayFields}</p>
                </div>
                <div class="mt-3 flex space-x-2">
                    <button class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-2 rounded-md text-sm font-medium transition-colors duration-200 flex items-center cursor-pointer"
                            onclick="selectSession({session: '${session.session}', date: '${date}', time: '${time}', location: '${session.location}'})">
                        Selecionar
                    </button>
                    <button class="bg-gray-200 hover:bg-gray-300 text-gray-700 px-3 py-2 rounded-md text-sm font-medium transition-colors duration-200 flex items-center cursor-pointer"
                            onclick="showPresentations('${session.session}')">
                        Ver Apresentações
                    </button>
                </div>
            `;

      return card;
    }

    // Select a session
    function selectSession(sessionData) {
      const { session, date, time } = sessionData;
      // Extract start time only
      const startTime = time.split('-')[0];
      const key = `${date}-${startTime}`;

      // Get current selections from URL
      let selectedSessions = getSelectedSessions();

      // Update selection
      selectedSessions[key] = session;

      // Save to URL
      updateUrlWithSelections(selectedSessions);

      // Refresh the display
      displaySessions();
      updateButtons();
    }

    // Update URL with selected sessions using compact format
    function updateUrlWithSelections(selectedSessions) {
      const newUrl = new URL(window.location.href);
      
      if (Object.keys(selectedSessions).length > 0) {
        // Create a compact array of session IDs for the URL
        const sessionIds = [];
        
        // For each date-time key, get the session ID
        Object.entries(selectedSessions).forEach(([key, sessionName]) => {
          // Find the session object to get a unique identifier
          // Use case-insensitive comparison
          const session = sessions.find(s => 
            s.session.toLowerCase() === sessionName.toLowerCase()
          );
          if (session) {
            // Create a compact ID using the session name and date-time
            const sessionId = createSessionId(session, key);
            sessionIds.push(sessionId);
          } else {
            // Create a fallback ID using just the session name hash and date-time
            const [date, time] = key.split('-');
            const dateSimple = date.replace(/\//g, '').substring(4);
            const timeStart = time.split('-')[0];
            const timeSimple = timeStart.replace(/\D/g, '');
            const timeSimplePadded = timeSimple.padStart(4, '0').substring(0, 4);
            const sessionHash = hashString(sessionName).substring(0, 4);
            const fallbackId = `${dateSimple}${timeSimplePadded}${sessionHash}`;
            sessionIds.push(fallbackId);
          }
        });
        
        if (sessionIds.length > 0) {
          newUrl.searchParams.set('s', sessionIds.join('-'));
        } else {
          newUrl.searchParams.delete('s');
        }
      } else {
        newUrl.searchParams.delete('s');
      }
      
      // Update URL without reloading the page
      window.history.pushState({}, '', newUrl);
    }
    
    // Create a unique but short ID for a session
    function createSessionId(session, dateTimeKey) {
      // Extract date and time from the key
      const [date, time] = dateTimeKey.split('-');
      
      // Add safety check if session or session.session is undefined
      if (!session || !session.session) {
        // Create a fallback hash based on date and time
        const dateSimple = date.replace(/\//g, '').substring(4);
        // Extract only the start time if it includes a range
        const timeStart = time.split('-')[0]; 
        const timeSimple = timeStart.replace(/\D/g, '');
        const timeSimplePadded = timeSimple.padStart(4, '0').substring(0, 4);
        const fallbackHash = hashString(dateTimeKey).substring(0, 4);
        const fallbackId = `${dateSimple}${timeSimplePadded}${fallbackHash}`;
        return fallbackId;
      }
      
      // Process the date to a simpler format (MMDD)
      const dateSimple = date.replace(/\//g, '').substring(4); // Remove slashes and get only month and day
      
      // Process the time to a simpler format (HHMM)
      // Extract only the start time and remove any non-digit characters
      const timeStart = time.split('-')[0]; // Get only start time
      const timeSimple = timeStart.replace(/\D/g, ''); // Remove all non-digits
      
      // Pad to ensure we have 4 digits
      const timeSimplePadded = timeSimple.padStart(4, '0').substring(0, 4);
      
      // Create a hash of the session name (use only first 4 chars for compactness)
      const sessionHash = hashString(session.session.toLowerCase()).substring(0, 4);
      
      // Combine them all
      const sessionId = `${dateSimple}${timeSimplePadded}${sessionHash}`;
      
      return sessionId;
    }
    
    // Get selected sessions from URL using compact format
    function getSelectedSessions() {
      const urlParams = new URLSearchParams(window.location.search);
      const sessionsParam = urlParams.get('s');
      
      if (!sessionsParam) {
        return {};
      }
      
      const selectedSessions = {};
      const sessionIds = sessionsParam.split('-');
      
      // Loop through all session IDs in the URL
      sessionIds.forEach(sessionId => {
        // Parse the session ID to extract date and time
        const dateTime = parseSessionId(sessionId);
        
        if (dateTime) {
          // Find matching session
          const matchedSession = findSessionByIdAndDateTime(sessionId, dateTime);
          if (matchedSession) {
            selectedSessions[dateTime] = matchedSession.session;
          }
        }
      });
      
      return selectedSessions;
    }
    
    // Parse a session ID back to its date-time key
    function parseSessionId(sessionId) {
      if (sessionId.length >= 8) { // Ensure we have enough characters
        // Extract date part (MMDD)
        const month = sessionId.substring(0, 2);
        const day = sessionId.substring(2, 4);
        
        // Extract time part (HHMM)
        const hour = sessionId.substring(4, 6);
        const minute = sessionId.substring(6, 8);
        
        // Reconstruct the date-time key
        const eventYear = 2025; // Hard-coded for this specific event
        
        // Create the basic date-time without specific formatting yet
        const dateKey = `${eventYear}/${month}/${day}`;
        const baseTimeKey = `${hour}${minute}`; // Just digits
        
        // Look for matching sessions to determine the right format
        const matchingSessions = sessions.filter(s => s.date === dateKey);
        
        if (matchingSessions.length > 0) {
          // Try to find a session with matching start time (ignoring end time)
          for (const session of matchingSessions) {
            // Extract just the digits from the start time for comparison
            const sessionTimeStart = session.time.split('-')[0];
            const sessionTimeDigits = sessionTimeStart.replace(/\D/g, '');
            
            // If we find a matching time, use that session's time format
            if (sessionTimeDigits === baseTimeKey || 
                // Handle special cases where padding might differ
                (sessionTimeDigits.length >= 3 && baseTimeKey.endsWith(sessionTimeDigits)) ||
                (baseTimeKey.length >= 3 && sessionTimeDigits.endsWith(baseTimeKey))) {
              
              return `${dateKey}-${sessionTimeStart}`;
            }
          }
          
          // If no exact match found, use the first session's time format as template
          const templateSession = matchingSessions[0];
          const timeFormat = templateSession.time.split('-')[0]; // Use only start time
          
          // Check if time format uses h or : and reconstruct accordingly
          let reconstructedTime;
          if (timeFormat.includes('h')) {
            reconstructedTime = `${hour}h${minute}`;
          } else if (timeFormat.includes(':')) {
            reconstructedTime = `${hour}:${minute}`;
          } else {
            // Unknown format, just use the basic format
            reconstructedTime = `${hour}h${minute}`;
          }
          
          return `${dateKey}-${reconstructedTime}`;
        } else {
          // No sessions found on this date, use a basic format
          return `${dateKey}-${hour}h${minute}`;
        }
      }
      return null;
    }
    
    // Find a session by its ID and date-time
    function findSessionByIdAndDateTime(sessionId, dateTime) {
      // Extract the hash part from the session ID (characters after position 8)
      const sessionHash = sessionId.substring(8);
      
      // Get the date and time parts
      const [datePart, timePart] = dateTime.split('-');
      
      // Extract start time only
      const timeStart = timePart.split('-')[0];
      
      // Find all sessions matching this date
      const matchingSessions = sessions.filter(s => s.date === datePart);
      
      // From these, find sessions with matching time start
      // We need to be flexible with time format
      const timeMatchingSessions = matchingSessions.filter(s => {
        const sessionTimeStart = s.time.split('-')[0];
        // Normalize both times to remove h/: for comparison
        const normalizedTimeStart = timeStart.replace(/[h:]/g, '');
        const normalizedSessionTimeStart = sessionTimeStart.replace(/[h:]/g, '');
        return normalizedTimeStart === normalizedSessionTimeStart;
      });
      
      // From these, find the one with the matching hash
      for (const session of timeMatchingSessions) {
        const sessionNameHash = hashString(session.session.toLowerCase()).substring(0, 4);
        const lowerSessionHash = sessionHash.toLowerCase();
        if (sessionNameHash === lowerSessionHash) {
          return session;
        }
      }
      
      // If exact hash match fails, try partial match with case-insensitivity
      for (const session of timeMatchingSessions) {
        if (hashString(session.session.toLowerCase()).includes(sessionHash.toLowerCase())) {
          return session;
        }
      }
      
      // If we have only one session at this time slot, just return it
      if (timeMatchingSessions.length === 1) {
        return timeMatchingSessions[0];
      }
      
      return null;
    }
    
    // Create a simple hash from a string for compact IDs
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      // Convert to a base36 string for compactness
      return Math.abs(hash).toString(36);
    }

    // Extract the start time from format like "08h00-09h00" or "14h30-15h30"
    function getStartTime(timeStr) {
      const match = timeStr.match(/^(\d{2})h(\d{2})/);
      if (match) {
        return parseInt(match[1]) * 60 + parseInt(match[2]); // Convert to minutes for comparison
      }
      return 0;
    }

    // Show summary of selected sessions
    function showSessionsSummary() {
      const selectedSessions = getSelectedSessions();
      if (Object.keys(selectedSessions).length === 0) return;

      // Create array of selected session details
      let selectedSessionsDetails = [];
      Object.keys(selectedSessions).forEach(key => {
        const [date, time] = key.split('-');
        const sessionName = selectedSessions[key];
        const session = getSessionByName(sessionName);
        if (session) {
          selectedSessionsDetails.push({
            date,
            time,
            session: sessionName,
            location: session.location,
            presentations: session.presentations.length
          });
        }
      });

      // Sort by date and time
      selectedSessionsDetails.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        return a.time.localeCompare(b.time);
      });

      // Create modal for summary
      const summaryModal = document.createElement('div');
      summaryModal.classList = "fixed top-0 left-0 right-0 w-full h-screen bg-black/75 flex items-center justify-center z-30 p-6";
      summaryModal.id = 'summaryModal';

      let sessionsList = '';
      selectedSessionsDetails.forEach(details => {
        // Get the session to access presentation details
        const session = getSessionByName(details.session);

        // Create list of presentations with links to abstracts
        let presentationsList = '';
        if (session && session.presentations) {
          // Sort presentations by hour
          const sortedPresentations = [...session.presentations].sort((a, b) => {
            return getStartTime(a.hour) - getStartTime(b.hour);
          });
          
          presentationsList = `
            <div class="mt-3 border-t border-gray-200 pt-3">
              <p class="text-sm font-medium text-gray-700 mb-2">Apresentações:</p>
              <ul class="text-sm space-y-1 pl-4">
                ${sortedPresentations.map(pres => `
                  <li>
                    <a href="${pres.abstract}" target="_blank" class="text-blue-600 hover:text-blue-800 cursor-pointer">
                      ${pres.hour}: ${pres.title}
                    </a>
                  </li>
                `).join('')}
              </ul>
            </div>
          `;
        }

        sessionsList += `
          <div class="border border-gray-300 p-4 rounded-lg mb-4 bg-white shadow-sm">
            <div>
              <h3 class="font-bold text-lg mb-1 text-gray-800">${details.session}</h3>
              <p class="text-sm text-gray-600">
                ${formatDate(details.date)} | ${details.time} | ${details.location}
              </p>
              ${presentationsList}
            </div>
          </div>
        `;
      });

      summaryModal.innerHTML = `
        <div class="bg-white rounded-lg shadow-lg max-w-4xl w-full">
          <div class="flex justify-between items-center border-b border-gray-300 p-6">
            <div>
              <h2 class="text-2xl font-bold text-gray-800">Resumo das Sessões Selecionadas</h2>
              <p class="text-sm text-gray-600">
                Total: ${selectedSessionsDetails.length} sessões
              </p>
            </div>
            <button class="text-gray-500 hover:text-gray-700 cursor-pointer" onclick="closeSummaryModal()">
              &cross;
            </button>
          </div>
          <div class="max-h-[75vh] overflow-y-auto p-4">
            ${sessionsList}
          </div>
          <div class="border-t border-gray-300 p-4 flex justify-between">
            <div class="flex space-x-3">
              <button class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200 cursor-pointer"
                      onclick="exportSelections()">
                🖨️ Imprimir Agenda
              </button>
              <button class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200 cursor-pointer"
                      onclick="shareSelections()">
                🔗 Compartilhar Agenda
              </button>
            </div>
            <button class="bg-gray-300 hover:bg-gray-400 text-gray-700 px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200 cursor-pointer"
                    onclick="closeSummaryModal()">
              Fechar
            </button>
          </div>
        </div>
      `;

      document.body.appendChild(summaryModal);

      // Close modal when clicking outside
      summaryModal.onclick = function (e) {
        if (e.target === summaryModal) {
          closeSummaryModal();
        }
      };
    }

    // Export selections as printable HTML page
    function exportSelections() {
      const selectedSessions = getSelectedSessions();
      if (Object.keys(selectedSessions).length === 0) return;

      // Create array of selected session details
      let selectedSessionsDetails = [];
      Object.keys(selectedSessions).forEach(key => {
        const [date, time] = key.split('-');
        const sessionName = selectedSessions[key];
        const session = getSessionByName(sessionName);
        if (session) {
          // Sort presentations by hour before adding to the details
          const sortedPresentations = [...session.presentations].sort((a, b) => {
            return getStartTime(a.hour) - getStartTime(b.hour);
          });
          
          selectedSessionsDetails.push({
            date,
            time,
            session: sessionName,
            location: session.location,
            presentations: sortedPresentations
          });
        }
      });

      // Sort by date and time
      selectedSessionsDetails.sort((a, b) => {
        if (a.date !== b.date) return a.date.localeCompare(b.date);
        return a.time.localeCompare(b.time);
      });

      // Build HTML for the print page with Tailwind CSS
      let printHTML = `
    <!DOCTYPE html>
    <html lang="pt-BR">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Minha Agenda EOSBF 2025</title>
      <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"><\/script>
      <style>
        @media print {
          .no-print {
            display: none;
          }
          @page {
            size: A4;
            margin: 1cm;
          }
          body {
            print-color-adjust: exact;
            -webkit-print-color-adjust: exact;
          }
        }
      </style>
    </head>
    <body class="bg-gray-50 text-gray-800 font-sans leading-relaxed">
      <div class="max-w-4xl mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-center mb-8 text-gray-900">Minha Agenda EOSBF 2025</h1>
  `;

      selectedSessionsDetails.forEach((details, index) => {
        printHTML += `
      <div class="mb-10 bg-white rounded-xl overflow-hidden p-6 break-inside-avoid border border-gray-200">
        <div class="border-b border-gray-200 pb-4 mb-4">
          <h2 class="text-2xl font-bold text-gray-800">${formatDate(details.date)} - ${details.time}</h2>
          <h2 class="text-gray-700">${details.session}</h2>
          <p class="text-gray-600">${details.location}</p>
        </div>
        
        <div class="space-y-2">
          <h3 class="text-xl font-semibold text-gray-800 mb-3">Apresentações:</h3>
    `;

        details.presentations.forEach(pres => {
          printHTML += `
            <div class="p-4 bg-blue-50 rounded-md mb-4">
              <div class="font-bold text-gray-900">
                ${pres.hour}: <a href="${pres.abstract}" target="_blank" class="text-blue-600 hover:text-blue-800 cursor-pointer">${pres.title}</a>
              </div>
         `;

          if (pres.presentedBy) {
            printHTML += `
            <div class="mt-2 text-gray-700">
              <span class="font-semibold">Apresentado por</span>: ${pres.presentedBy}<br>
              <span class="font-semibold">Universidade</span>: ${pres.authors.find((author) => author.author === pres.presentedBy)?.universities.join(", ")}<br>
            </div>
          `;
          }

          printHTML += `</div>`;
        });

        printHTML += `
        </div>
      </div>
    `;
      });

      printHTML += `
      </div>
    </body>
    </html>
  `;

      // Open the print page in a new tab
      const printWindow = window.open('', '_blank');
      printWindow.document.write(printHTML);
      printWindow.document.close();

      // Trigger print dialog after page loads
      printWindow.onload = function () {
        printWindow.focus();
        setTimeout(() => {
          printWindow.print();
        }, 500);
      };
    }

    // Clear all selections
    function clearAllSelections() {
      updateUrlWithSelections({});
      displaySessions();
      updateButtons();
    }

    // Remove a session selection
    function removeSession(key) {
      // Make sure we're using only the start time in the key
      const [date, fullTime] = key.split('-');
      const startTime = fullTime.split('-')[0];
      const normalizedKey = `${date}-${startTime}`;
      
      // Get current selections
      let selectedSessions = getSelectedSessions();
      
      // Remove the selection
      delete selectedSessions[normalizedKey];

      // Update URL
      updateUrlWithSelections(selectedSessions);

      // Refresh UI
      displaySessions();
      updateButtons();
    }

    // Format date from YYYY-MM-DD to more readable format
    function formatDate(dateStr) {
      const date = new Date(dateStr);
      return capitalizeFirstLetter(date.toLocaleDateString('pt-BR', {
        weekday: 'long',
        year: undefined,
        month: 'long',
        day: 'numeric'
      }));
    }

    // Get the session by name
    function getSessionByName(sessionName) {
      if (!sessionName) {
        return null;
      }
      
      // Use case-insensitive comparison
      const session = sessions.find(s => 
        s.session.toLowerCase() === sessionName.toLowerCase()
      );
      
      return session;
    }

    // Create Google Calendar link
    function createGoogleCalendarLink(date, timeStr, sessionName, location) {
      try {
        // Parse date (format: YYYY/MM/DD)
        const [year, month, day] = date.split('/').map(Number);
        
        // Parse time (format: HHh00-HHh00 or HHhMM-HHhMM)
        const timeRange = timeStr.split('-');
        const startTimeStr = timeRange[0]; // e.g., "15h00" or "15h30"
        const endTimeStr = timeRange[1] || ""; // e.g., "16h00" or "16h30"
        
        // Extract hours and minutes
        const startTimeParts = startTimeStr.split('h');
        const startHour = parseInt(startTimeParts[0], 10);
        const startMinute = startTimeParts.length > 1 ? parseInt(startTimeParts[1], 10) : 0;
        
        let endHour, endMinute;
        if (endTimeStr) {
          const endTimeParts = endTimeStr.split('h');
          endHour = parseInt(endTimeParts[0], 10);
          endMinute = endTimeParts.length > 1 ? parseInt(endTimeParts[1], 10) : 0;
        } else {
          // Default to 2 hours later if no end time
          endHour = startHour + 2;
          endMinute = startMinute;
        }
        
        // Create start and end date strings in the format YYYYMMDDTHHMMSS
        const formatDigit = (num) => num.toString().padStart(2, '0');
        
        const startDateStr = `${year}${formatDigit(month)}${formatDigit(day)}T${formatDigit(startHour)}${formatDigit(startMinute)}00`;
        const endDateStr = `${year}${formatDigit(month)}${formatDigit(day)}T${formatDigit(endHour)}${formatDigit(endMinute)}00`;
        
        // Create details string with session details
        const details = `<b>Sessão:</b> ${sessionName}\n<b>Local:</b> ${location}`;
        
        // Build the Google Calendar URL
        return `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(sessionName)}&details=${encodeURIComponent(details)}&dates=${startDateStr}/${endDateStr}&ctz=America/Sao_Paulo`;
      } catch (error) {
        // Return fallback link
        return '#';
      }
    }

    // Display presentations for a session
    function showPresentations(sessionName) {
      const session = getSessionByName(sessionName);
      if (!session) {
        // Display a warning to the user
        const warningToast = document.createElement('div');
        warningToast.className = 'fixed bottom-4 right-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded shadow-md z-50';
        warningToast.innerHTML = `
          <div class="flex items-center">
            <div class="py-1"><svg class="fill-current h-6 w-6 text-red-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M10 0C4.477 0 0 4.477 0 10c0 5.523 4.477 10 10 10s10-4.477 10-10c0-5.523-4.477-10-10-10zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8zm0-13a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V6a1 1 0 0 0-1-1zm0 8a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"/></svg></div>
            <div>
              <p class="font-bold">Erro ao carregar a sessão</p>
              <p class="text-sm">Não foi possível encontrar detalhes para a sessão "${sessionName}".</p>
            </div>
          </div>
        `;
        document.body.appendChild(warningToast);
        
        // Remove toast after 5 seconds
        setTimeout(() => {
          warningToast.remove();
        }, 5000);
        
        return;
      }

      // Close summary modal if open
      closeSummaryModal();

      // Sort presentations by hour
      const sortedPresentations = [...session.presentations].sort((a, b) => {
        return getStartTime(a.hour) - getStartTime(b.hour);
      });

      // Create modal content for presentations
      const presentationsModal = document.createElement('div');
      presentationsModal.classList = "fixed top-0 left-0 right-0 w-full h-screen bg-black/75 flex items-center justify-center z-30 p-6";
      presentationsModal.id = 'presentationsModal';

      const modalWidth = sortedPresentations.length > 2 ? 'max-w-6xl' : 'max-w-2xl';

      let presentationsHTML = '';
      sortedPresentations.forEach(presentation => {
        // Get all unique universities from the authors
        const universities = presentation.authors.reduce((acc, author) => {
          author.universities.forEach(uni => {
            if (!acc.includes(uni)) acc.push(uni);
          });
          return acc;
        }, []);

        presentationsHTML += `
                <div class="border border-gray-300 p-4 rounded-lg mb-4 bg-white shadow-sm">
                    <h3 class="font-bold text-lg mb-2 text-gray-800"><a href="${presentation.abstract}" target="_blank" class="text-blue-600 hover:text-blue-800 cursor-pointer">${presentation.title}</a> &#8599;</h3>
                    <div class="flex flex-wrap gap-2 mb-3">
                        <span class="bg-blue-100 text-blue-800 text-xs text-center px-2 py-1 rounded">
                            &#127891; ${presentation.field}
                        </span>
                        <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded">
                            &#128336; ${presentation.hour}
                        </span>
                    </div>
                    <div class="border-t border-gray-300 pt-2 mt-2">
                        <p class="text-sm font-medium">Apresentador: ${presentation.presentedBy}</p>
                        <div class="mt-2">
                            <p class="text-xs font-medium text-gray-500">Autores:</p>
                            <ul class="text-sm ml-4 list-disc">
                                ${presentation.authors.map(author => `
                                    <li>${author.author} 
                                        <span class="text-xs text-gray-500">(${author.universities.join(', ')})</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                </div>
                `;
      });

      presentationsModal.innerHTML = `
                <div class="bg-white rounded-lg shadow-lg ${modalWidth} w-full">
                  <div class="flex justify-between items-center border-b border-gray-300 p-6">
                      <div>
                          <h2 class="text-2xl font-bold text-gray-800">${session.session}</h2>
                          <p class="text-sm text-gray-600">
                              ${formatDate(session.date)} &nbsp;|&nbsp; ${session.time} &nbsp;|&nbsp; ${session.location}
                          </p>
                      </div>
                      <button class="text-gray-500 hover:text-gray-700 cursor-pointer" onclick="closeModal()">
                          &cross;
                      </button>
                  </div>
                  <div class="max-h-[75vh] overflow-y-auto p-4">
                    <div class="presentations-grid ${sortedPresentations.length > 2 ? 'grid grid-cols-1 md:grid-cols-3 gap-4' : 'space-y-4'}">
                      ${presentationsHTML}
                    </div>
                  </div>
                </div>
            `;

      document.body.appendChild(presentationsModal);

      // Close modal when clicking outside
      presentationsModal.onclick = function (e) {
        if (e.target === presentationsModal) {
          closeModal();
        }
      };
    }

    // Close modals functions
    function closeModal() {
      document.getElementById('presentationsModal')?.remove();
    }

    function closeSummaryModal() {
      document.getElementById('summaryModal')?.remove();
    }

    // Capitalize first letter
    function capitalizeFirstLetter(val) {
      return String(val).charAt(0).toUpperCase() + String(val).slice(1);
    }

    // Set onclick for the buttons
    document.getElementById('clearAllBtn').onclick = clearAllSelections;
    document.getElementById('clearAllBtnMobile').onclick = clearAllSelections;
    document.getElementById('viewSummaryBtn').onclick = showSessionsSummary;
    document.getElementById('viewSummaryBtnMobile').onclick = showSessionsSummary;

    // Check for selections on load to update buttons
    window.onload = function () {
      // Load data first, then initialize UI
      Promise.all([
        fetch('oral-sessions.json').then(response => response.json()),
        fetch('invited-lectures.json').then(response => response.json()),
        fetch('intervals.json').then(response => response.json())
      ])
      .then(([oralSessionsData, invitedLecturesData, intervalsData]) => {
        // Process the data (existing code from the Promise.all callback)
        const sessionsMap = new Map();
        
        // Process oral sessions
        oralSessionsData.forEach(session => {
          sessionsMap.set(session.session, session);
        });
        
        // Process invited lectures, merging presentations if session already exists
        invitedLecturesData.forEach(session => {
          // Check both exact match and case-insensitive match
          const exactMatch = sessionsMap.has(session.session);
          const lowerCaseSession = session.session.toLowerCase();
          
          // Find case-insensitive match if no exact match
          let matchedKey = exactMatch ? session.session : null;
          if (!exactMatch) {
            // Look for case-insensitive match
            for (const [key] of sessionsMap) {
              if (key.toLowerCase() === lowerCaseSession) {
                matchedKey = key;
                break;
              }
            }
          }
          
          if (matchedKey) {
            // Merge presentations from both arrays
            const existingSession = sessionsMap.get(matchedKey);
            existingSession.presentations = [
              ...existingSession.presentations,
              ...session.presentations
            ];
            // If we found a case-insensitive match, use the more canonical format
            if (!exactMatch) {
              existingSession.session = session.session; // Use the case from invited lectures
            }
          } else {
            sessionsMap.set(session.session, session);
          }
        });
        
        // Convert map back to array and add intervals
        sessions = [...sessionsMap.values(), ...intervalsData];
        
        // Now check if we have URL parameters and update the UI
        try {
          if (window.location.search.includes('s=')) {
            const selectedSessions = getSelectedSessions();
            
            if (Object.keys(selectedSessions).length > 0) {
              // Force redisplay with selections
              displaySessions();
            }
          } else {
            // No URL parameters, just display the sessions
            displaySessions();
          }
        } catch (err) {
          // Still display sessions even if there was an error
          displaySessions();
        }
        
        // Update UI states
        updateButtons();
      })
      .catch(error => {
        sessionsContainer.innerHTML = "<div style='text-align: center; width: 100%;'>Erro ao carregar as sessões.<br/>Os arquivos <code>oral-sessions.json</code>, <code>invited-lectures.json</code> e <code>intervals.json</code> estão no lugar?</div>"
      });
    };

    // Share selections by copying URL to clipboard
    function shareSelections() {
      const url = window.location.href;
      
      // Try to use the modern clipboard API with fallback
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url)
          .then(showSuccessToast)
          .catch(err => {
            // Fallback if clipboard API fails
            fallbackCopyToClipboard(url);
          });
      } else {
        fallbackCopyToClipboard(url);
      }
    }
    
    // Fallback method for copying to clipboard
    function fallbackCopyToClipboard(text) {
      // Create a temporary input to copy the URL
      const tempInput = document.createElement('input');
      tempInput.value = text;
      tempInput.style.position = 'fixed';
      tempInput.style.opacity = '0';
      document.body.appendChild(tempInput);
      tempInput.select();
      
      try {
        // Copy URL to clipboard
        const success = document.execCommand('copy');
        if (success) {
          showSuccessToast();
        } else {
          throw new Error('Could not copy text');
        }
      } catch (err) {
        alert('Não foi possível copiar o URL. Por favor, copie manualmente da barra de endereço.');
      }
      
      // Clean up
      document.body.removeChild(tempInput);
    }
    
    // Show success toast when URL is copied
    function showSuccessToast() {
      const toast = document.createElement('div');
      toast.className = 'fixed bottom-4 right-4 bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded shadow-md z-50';
      toast.innerHTML = `
        <div class="flex items-center">
          <div class="py-1"><svg class="fill-current h-6 w-6 text-green-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM6.7 9.29L9 11.6l4.3-4.3 1.4 1.42L9 14.4l-3.7-3.7 1.4-1.42z"/></svg></div>
          <div>
            <p class="font-bold">URL copiada para área de transferência!</p>
            <p class="text-sm">Compartilhe com seus colegas.</p>
          </div>
        </div>
      `;
      document.body.appendChild(toast);
      
      // Remove toast after 3 seconds
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }
  </script>
</body>

</html>